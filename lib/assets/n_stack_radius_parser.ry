class NStackRadiusParser
  prechigh
    left '*' '/' '%'
    left '+' '-'
    nonassoc '==' '!=' '<' '<=' '>' '>='
  preclow

  rule
    program
        : phases                                                            {result = [:program, nil, [val[0]]]}

    phases
        :                                                                   {result = [:phases, nil, []]}
        | phases phase                                                      {result[2] << val[1]}

    phase
        : PHASE identifier '{' statements '}'                               {result = [:phase, val[3], [val[1]]]}

    do_statement
        : identifier DO '{' statements '}'                                  {result = [:do, val[3], [val[0]]]}

    if_else_statement
        : if_statement elsif_statements else_statement                       {result = [:if, val[0] + val[1] + val[2], nil]}

    if_statement
        : IF expr '{' statements '}'                                        {result = [val[1], val[3]]}

    elsif_statements
        :                                                                   {result = []}
        | elsif_statements ELSE IF expr '{' statements '}'                  {result << val[3] << val[5]}

    else_statement
        :                                                                   {result = []}
        | ELSE '{' statements '}'                                           {result = [[:boolean, true, nil], val[2]]}

    statements
        :                                                                   {result = [:statements, nil, []]}
        | statements statement                                              {result[2] << val[1]}
        | statements statement ';'                                          {result[2] << val[1]}

    statement
        : expr
        | identifier '=' expr                                               {result = [:assign_variable, nil, [val[2], val[0], [:null, nil, nil]]]}
        | expr '[' expr ']' '=' expr                                        {result = [:assign_variable, nil, [val[5], val[2], val[0]]]}
        | expr '.' identifier '=' expr                                      {result = [:assign_variable, nil, [val[4], val[2], val[0]]]}
        | do_statement
        | if_else_statement
        | GOTO identifier                                                   {result = [:goto, nil, [val[1]]]}

    arguments
        : expr                                                              {result = [:arguments, nil, [val[0]]]}
        | arguments ',' expr                                                {result[2] << val[2]}

    key_values
        : string ':' expr                                                   {result = [:key_values, nil, [val[0], val[2]]]}
        | key_values ',' string ':' expr                                    {result[2] << val[2] << val[4]}

    expr
        : expr '+' expr                                                     {result = [:add, nil, [val[0], val[2]]]}
        | expr '-' expr                                                     {result = [:dif, nil, [val[0], val[2]]]}
        | expr '*' expr                                                     {result = [:mul, nil, [val[0], val[2]]]}
        | expr '/' expr                                                     {result = [:div, nil, [val[0], val[2]]]}
        | expr '%' expr                                                     {result = [:mod, nil, [val[0], val[2]]]}
        | expr '==' expr                                                    {result = [:eq,  nil, [val[0], val[2]]]}
        | expr '!=' expr                                                    {result = [:neq, nil, [val[0], val[2]]]}
        | expr '<' expr                                                     {result = [:lt,  nil, [val[0], val[2]]]}
        | expr '<=' expr                                                    {result = [:lte, nil, [val[0], val[2]]]}
        | expr '>' expr                                                     {result = [:gt,  nil, [val[0], val[2]]]}
        | expr '>=' expr                                                    {result = [:gte, nil, [val[0], val[2]]]}
        | number
        | string
        | boolean
        | identifier                                                        {result = [:reference_variable, nil, [val[0]]]}
        | '(' expr ')'                                                      {result = val[1]}
        | expr '[' expr ']'                                                 {result = [:index, nil, [val[0], val[2]]]}
        | expr '.' identifier                                               {result = [:index, nil, [val[0], val[2]]]}
        | identifier '(' ')'                                                {result = [:call_function, nil, [val[0]]]}
        | identifier '(' arguments ')'                                      {result = [:call_function, nil, [val[0], val[2]]]}
        | '[' ']'                                                           {result = [:define_array, nil, nil]}
        | '[' arguments ']'                                                 {result = [:define_array, nil, [val[1]]]}
        | '{' '}'                                                           {result = [:define_hash, nil, nil]}
        | '{' key_values '}'                                                {result = [:define_hash, nil, [val[1]]]}

    number
        : NUMBER                                                            {result = [:number, val[0], nil]}
    string
        : STRING                                                            {result = [:string, val[0], nil]}
    boolean
        : BOOLEAN                                                           {result = [:boolean, val[0], nil]}
    identifier
        : IDENTIFIER                                                        {result = [:identifier, val[0], nil]}
end

---- header

require 'strscan'
require 'pp'

---- inner

def parse(str)
    scanner = StringScanner.new(str)
    @q = []
    while !scanner.eos?
        scanner.scan(/[\s\n]+/)
        scanner.scan(/\<=/) ?                       @q << ['<=', '<='] :
        scanner.scan(/\>=/) ?                       @q << ['>=', '>='] :
        scanner.scan(/\</) ?                        @q << ['<', '<'] :
        scanner.scan(/\>/) ?                        @q << ['>', '>'] :
        scanner.scan(/\==/) ?                       @q << ['==', '=='] :
        scanner.scan(/\!=/) ?                       @q << ['!=', '!='] :
        scanner.scan(/\".*?\"/) ?                   @q << [:STRING, scanner.matched[1..-2]] :
        scanner.scan(/\'.*?\'/) ?                   @q << [:STRING, scanner.matched[1..-2]] :
        scanner.scan(/[a-zA-Z_][a-zA-Z0-9_]*/) ?
        (case scanner.matched.to_s
            when "phase"
                @q << [:PHASE, :PHASE]
            when "true"
                @q << [:BOOLEAN, true]
            when "false"
                @q << [:BOOLEAN, false]
            when "do"
                @q << [:DO, :do]
            when "goto"
                @q << [:GOTO, :goto]
            when "if"
                @q << [:IF, :if]
            when "else"
                @q << [:ELSE, :else]
            else
                @q << [:IDENTIFIER, scanner.matched.to_s]
        end) :
        scanner.scan(/([0-9]*\.[0-9]+)/) ?          @q << [:NUMBER, scanner.matched.to_f] :
        scanner.scan(/(0|[1-9][0-9]*)/) ?           @q << [:NUMBER, scanner.matched.to_i] :
        scanner.scan(/./) ?                         @q << [scanner.matched, scanner.matched] :
        raise("parse error")
    end
    tree = do_parse
    pp tree
    convert(tree)
end

def next_token
    @q.shift
end

def convert(tree)
    stack = [tree]
    operations = []
    while !stack.empty?
        node = stack.pop()
        # node[0]はノードの識別子
        # node[1]はノードの持つ固有値(値)
        # node[2]はノードの持つ引数(配列)
        #puts "NODE:#{node[0]}"
        #puts "CHILDREN:#{node[2]}"
        case node[0]
            when :phase # phase文は特別な処理を行う
                node[2].each do |child|
                    stack.push(child)
                end
                operations.push([:phase, convert(node[1]), node[2].length])

            when :do # do文は特別な処理を行う
                node[2].each do |child|
                    stack.push(child)
                end
                operations.push([:do, convert(node[1]), node[2].length])

            when :if # if文は特別な処理を行う
                if_sets = []
                node[1].each do |child|
                    if_sets << convert(child)
                end
                operations.push([:if, if_sets, 0])
            else        # それ以外は同じ
                if node[2]
                    node[2].each do |child|
                        stack.push(child)
                    end
                    operations.push([node[0], node[1], node[2].length])
                else
                    operations.push([node[0], node[1], 0])
                end
        end
    end
    operations
end

---- footer

if __FILE__ == $0
    parser = NStackRadiusParser.new
    prg = ""
    File.open("program.rlb", "r") do |f|
        prg = f.read.chomp
    end
    pp parser.parse(prg)

end